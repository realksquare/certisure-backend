"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PDFParse = void 0;
const pdf_worker_min_mjs_url_1 = __importDefault(require("pdfjs-dist/build/pdf.worker.min.mjs?url"));
const pdfjs = __importStar(require("pdfjs-dist/legacy/build/pdf.mjs"));
const Geometry_1 = require("./geometry/Geometry");
const ImageResult_1 = require("./ImageResult");
const PathGeometry_1 = require("./PathGeometry");
const TextResult_1 = require("./TextResult");
if (typeof globalThis.pdfjs === 'undefined') {
    globalThis.pdfjs = pdfjs;
}
// Only run in real browser environments
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    if (pdfjs?.GlobalWorkerOptions) {
        // set workerSrc only if not already set
        if (!pdfjs.GlobalWorkerOptions.workerSrc) {
            pdfjs.GlobalWorkerOptions.workerSrc = pdf_worker_min_mjs_url_1.default;
        }
    }
}
class PDFParse {
    options;
    doc;
    constructor(options) {
        if (typeof options.data === 'object' && 'buffer' in options.data) {
            options.data = new Uint8Array(options.data);
        }
        options.verbosity = pdfjs.VerbosityLevel.ERRORS;
        this.options = options;
    }
    async GetText() {
        const result = { ...TextResult_1.TextResultDefault };
        const infoData = await this.load();
        Object.assign(result, infoData);
        if (this.doc === undefined) {
            throw new Error('PDF document not loaded');
        }
        for (let i = 1; i <= result.total; i++) {
            if (this.shouldParse(i, result.total)) {
                const pageProxy = await this.doc.getPage(i);
                const text = await this.getPageText(pageProxy);
                result.pages.push({
                    text: text,
                    num: i,
                });
                pageProxy.cleanup();
            }
        }
        await this.doc.destroy();
        this.doc = undefined;
        for (const page of result.pages) {
            result.text += `${page.text}\n\n`;
        }
        return result;
    }
    async load() {
        const opts = { ...this.options };
        if (this.options.data instanceof Uint8Array) {
            opts.data = new Uint8Array(this.options.data);
        }
        const loadingTask = pdfjs.getDocument(opts);
        this.doc = await loadingTask.promise;
        const data = await this.doc.getMetadata();
        return {
            total: this.doc.numPages,
            info: data.info,
            metadata: data.metadata,
        };
    }
    shouldParse(currentPage, totalPage) {
        let parseFlag = false;
        if (this.options.partial) {
            if (this.options.first && currentPage <= this.options.first) {
                parseFlag = true;
            }
            if (!parseFlag) {
                if (this.options.last && currentPage > totalPage - this.options.last) {
                    parseFlag = true;
                }
            }
        }
        else {
            parseFlag = true;
        }
        return parseFlag;
    }
    async getPageText(page) {
        const textContent = await page.getTextContent({
            includeMarkedContent: false,
            disableNormalization: false,
        });
        const strBuf = [];
        for (const item of textContent.items) {
            if (!('str' in item))
                continue;
            strBuf.push(item.str);
            if (item.hasEOL) {
                strBuf.push('\n');
            }
        }
        return strBuf.join('');
    }
    async GetImage() {
        const result = { ...ImageResult_1.ImageResultDefault };
        const infoData = await this.load();
        Object.assign(result, infoData);
        if (this.doc === undefined) {
            throw new Error('PDF document not loaded');
        }
        for (let i = 1; i <= result.total; i++) {
            if (this.shouldParse(i, result.total)) {
                const page = await this.doc.getPage(i);
                const ops = await page.getOperatorList();
                const pageImages = { pageNumber: i, images: [] };
                result.pages.push(pageImages);
                for (let j = 0; j < ops.fnArray.length; j++) {
                    if (ops.fnArray[j] === pdfjs.OPS.paintInlineImageXObject || ops.fnArray[j] === pdfjs.OPS.paintImageXObject) {
                        const name = ops.argsArray[j][0];
                        const isCommon = page.commonObjs.has(name);
                        const imgPromise = isCommon ? this.resolveEmbeddedImage(page.commonObjs, name) : this.resolveEmbeddedImage(page.objs, name);
                        const { width, height, kind, data } = await imgPromise;
                        // biome-ignore lint/suspicious/noExplicitAny: <underlying library does not contain valid typedefs>
                        const canvasFactory = this.doc.canvasFactory;
                        const canvasAndContext = canvasFactory.create(width, height);
                        const context = canvasAndContext.context;
                        let imgData = null;
                        if (kind === pdfjs.ImageKind.RGBA_32BPP) {
                            imgData = context.createImageData(width, height);
                            imgData.data.set(data);
                        }
                        else {
                            imgData = context.createImageData(width, height);
                            this.convertToRGBA({
                                src: data,
                                dest: new Uint32Array(imgData.data.buffer),
                                width,
                                height,
                                kind,
                            });
                        }
                        context.putImageData(imgData, 0, 0);
                        const buff = canvasAndContext.canvas.toBuffer('image/png');
                        const base64 = buff.toString('base64');
                        const dataUrl = `data:image/png;base64,${base64}`;
                        pageImages.images.push({
                            data: buff,
                            dataUrl,
                            fileName: name,
                            height,
                            width,
                            kind,
                        });
                    }
                }
            }
        }
        await this.doc.destroy();
        this.doc = undefined;
        return result;
    }
    convertToRGBA({ src, dest, width, height, kind }) {
        if (kind === pdfjs.ImageKind.RGB_24BPP) {
            for (let i = 0, j = 0; i < src.length; i += 3, j++) {
                const r = src[i];
                const g = src[i + 1];
                const b = src[i + 2];
                dest[j] = (255 << 24) | (b << 16) | (g << 8) | r;
            }
        }
        else if (kind === pdfjs.ImageKind.GRAYSCALE_1BPP) {
            // Her bit bir pikseli temsil eder (0: siyah, 1: beyaz)
            let pixelIndex = 0;
            for (let i = 0; i < src.length; i++) {
                const byte = src[i];
                for (let bit = 7; bit >= 0; bit--) {
                    if (pixelIndex >= width * height)
                        break;
                    const isWhite = ((byte >> bit) & 1) === 1;
                    const gray = isWhite ? 255 : 0;
                    dest[pixelIndex++] = (255 << 24) | (gray << 16) | (gray << 8) | gray;
                }
            }
        }
        else {
            throw new Error(`convertToRGBA: Unsupported image kind: ${kind}`);
        }
    }
    resolveEmbeddedImage(pdfObjects, name) {
        return new Promise((resolve, reject) => {
            // biome-ignore lint/suspicious/noExplicitAny: <underlying library does not contain valid typedefs>
            pdfObjects.get(name, (imgData) => {
                if (imgData) {
                    const dataBuff = new Uint8Array(imgData.data);
                    resolve({ width: imgData.width, height: imgData.height, kind: imgData.kind, data: dataBuff });
                }
                else {
                    reject(new Error(`Image object ${name} not found`));
                }
            });
        });
    }
    async PageToImage() {
        const result = { pages: [], total: 0 };
        //const base = new URL('../../node_modules/pdfjs-dist/', import.meta.url);
        //this.options.cMapUrl = new URL('cmaps/', base).href;
        //this.options.cMapPacked = true;
        //this.options.standardFontDataUrl = new URL('legacy/build/standard_fonts/', base).href;
        const infoData = await this.load();
        Object.assign(result, infoData);
        if (this.doc === undefined) {
            throw new Error('PDF document not loaded');
        }
        for (let i = 1; i <= result.total; i++) {
            if (this.shouldParse(i, result.total)) {
                //const pageToImages: PageToImage = { pageNumber: i };
                //result.pages.push(pageToImages);
                const page = await this.doc.getPage(i);
                // biome-ignore lint/suspicious/noExplicitAny: <underlying library does not contain valid typedefs>
                const canvasFactory = this.doc.canvasFactory;
                const viewport = page.getViewport({ scale: 1.0 });
                const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);
                const renderContext = {
                    canvasContext: canvasAndContext.context,
                    viewport,
                    canvas: canvasAndContext.canvas,
                };
                const renderTask = page.render(renderContext);
                await renderTask.promise;
                // Convert the canvas to an image buffer.
                const data = canvasAndContext.canvas.toBuffer('image/png');
                const base64 = data.toString('base64');
                const dataUrl = `data:image/png;base64,${base64}`;
                result.pages.push({
                    data,
                    dataUrl,
                    pageNumber: i,
                });
                page.cleanup();
            }
        }
        await this.doc.destroy();
        this.doc = undefined;
        return result;
    }
    async GetTable() {
        const infoData = await this.load();
        const result = { ...infoData, pages: [], mergedTables: [] };
        if (this.doc === undefined) {
            throw new Error('PDF document not loaded');
        }
        for (let i = 1; i <= result.total; i++) {
            if (this.shouldParse(i, result.total)) {
                const page = await this.doc.getPage(i);
                const viewport = page.getViewport({ scale: 1 });
                //viewport.convertToViewportPoint(0, 0);
                const store = await this.getPageTables(page);
                //const store = await this.getPageGeometry(page);
                store.normalize();
                const tableDataArr = store.getTableData();
                await this.fillPageTables(page, tableDataArr);
                for (const table of tableDataArr) {
                    //if (table.cellCount < 3) continue
                    const pageTableResult = { num: i, tables: table.toArray() };
                    result.pages.push(pageTableResult);
                    //pageTableResult.tables.push(table.toData())
                }
                page.cleanup();
            }
        }
        // for (const table of Table.AllTables) {
        //     if (table.cellCount < 3) continue
        //     const str = table.toString()
        //     console.log(str)
        // }
        await this.doc.destroy();
        return result;
    }
    getPathGeometry(mm) {
        const width = mm[2] - mm[0];
        const height = mm[3] - mm[1];
        if (mm[0] === Infinity) {
            return PathGeometry_1.PathGeometry.undefined;
        }
        if (width > 5 && height > 5) {
            return PathGeometry_1.PathGeometry.rectangle;
        }
        else if (width > 5 && height === 0) {
            return PathGeometry_1.PathGeometry.hline;
        }
        else if (width === 0 && height > 5) {
            return PathGeometry_1.PathGeometry.vline;
        }
        return PathGeometry_1.PathGeometry.undefined;
    }
    async getPageTables(page) {
        const lineStore = new Geometry_1.LineStore();
        const viewport = page.getViewport({ scale: 1 });
        let transformMatrix = [1, 0, 0, 1, 0, 0];
        const transformStack = [];
        const opList = await page.getOperatorList();
        for (let i = 0; i < opList.fnArray.length; i++) {
            const fn = opList.fnArray[i];
            const args = opList.argsArray[i];
            const op = args?.[0] ?? 0;
            const mm = args?.[2] ?? [Infinity, Infinity, -Infinity, -Infinity];
            //const minMax = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
            if (fn === pdfjs.OPS.constructPath) {
                if (op === pdfjs.OPS.fill) {
                    //debugger;
                }
                if (op !== pdfjs.OPS.stroke) {
                    continue;
                }
                const pg = this.getPathGeometry(mm);
                if (pg === PathGeometry_1.PathGeometry.rectangle) {
                    const rect = new Geometry_1.Rectangle(new Geometry_1.Point(mm[0], mm[1]), mm[2] - mm[0], mm[3] - mm[1]);
                    rect.transform(transformMatrix);
                    rect.transform(viewport.transform);
                    lineStore.addRectangle(rect);
                }
                else if (pg === PathGeometry_1.PathGeometry.hline || pg === PathGeometry_1.PathGeometry.vline) {
                    const from = new Geometry_1.Point(mm[0], mm[1]);
                    const to = new Geometry_1.Point(mm[2], mm[3]);
                    const line = new Geometry_1.Line(from, to);
                    line.transform(transformMatrix);
                    line.transform(viewport.transform);
                    lineStore.add(line);
                }
                else {
                    debugger;
                }
                // if (op === pdfjs.OPS.rectangle) {
                // 	debugger;
                // } else if (op === pdfjs.OPS.moveTo) {
                // 	debugger;
                // } else if (op === pdfjs.OPS.lineTo) {
                // 	debugger;
                // } else if (op === pdfjs.OPS.endPath) {
                // 	const combinedMatrix = pdfjs.Util.transform(viewport.transform, transformMatrix);
                // 	// while (args[1].length) {
                // 	// 	const drawOp = args[1].shift();
                // 	// 	debugger;
                // 	// }
                // } else {
                // 	//debugger;
                // }
            }
            else if (fn === pdfjs.OPS.setLineWidth) {
                debugger;
            }
            else if (fn === pdfjs.OPS.save) {
                transformStack.push(transformMatrix);
            }
            else if (fn === pdfjs.OPS.restore) {
                const restoredMatrix = transformStack.pop();
                if (restoredMatrix) {
                    transformMatrix = restoredMatrix;
                }
            }
            else if (fn === pdfjs.OPS.transform) {
                //transformMatrix = this.transform_fn(transformMatrix, args);
                transformMatrix = pdfjs.Util.transform(transformMatrix, args);
            }
        }
        return lineStore;
    }
    async getPageGeometry(page) {
        const lineStore = new Geometry_1.LineStore();
        const opList = await page.getOperatorList();
        const viewport = page.getViewport({ scale: 1 });
        let transformMatrix = [1, 0, 0, 1, 0, 0];
        const transformStack = [];
        let current_x = 0;
        let current_y = 0;
        for (let j = 0; j < opList.fnArray.length; j++) {
            const fn = opList.fnArray[j];
            const args = opList.argsArray[j];
            if (fn === pdfjs.OPS.constructPath) {
                while (args[0].length) {
                    const op = args[0].shift();
                    const combinedMatrix = pdfjs.Util.transform(viewport.transform, transformMatrix);
                    if (op === pdfjs.OPS.rectangle) {
                        const x = args[1].shift();
                        const y = args[1].shift();
                        const width = args[1].shift();
                        const height = args[1].shift();
                        if (Math.min(width, height) <= 2) {
                            // TODO remove
                            debugger;
                        }
                        const rect = new Geometry_1.Rectangle(new Geometry_1.Point(x, y), width, height);
                        rect.transform(combinedMatrix);
                        //rect.transform(viewport.transform);
                        lineStore.addRectangle(rect);
                    }
                    else if (op === pdfjs.OPS.moveTo) {
                        current_x = args[1].shift();
                        current_y = args[1].shift();
                    }
                    else if (op === pdfjs.OPS.lineTo) {
                        const x = args[1].shift();
                        const y = args[1].shift();
                        //default trasform
                        const from = new Geometry_1.Point(current_x, current_y);
                        const to = new Geometry_1.Point(x, y);
                        const line = new Geometry_1.Line(from, to);
                        line.transform(combinedMatrix);
                        //line.transform(viewport.transform);
                        // // viewport transform
                        // const _from = viewport.convertToViewportPoint(line.from.x, line.from.y)
                        // const _to = viewport.convertToViewportPoint(line.to.x, line.to.y)
                        //
                        // const transformedLine = new Line(new Point(_from[0], _from[1]), new Point(_to[0], _to[1]))
                        lineStore.add(line);
                        current_x = x;
                        current_y = y;
                    }
                }
            }
            else if (fn === pdfjs.OPS.save) {
                transformStack.push(transformMatrix);
            }
            else if (fn === pdfjs.OPS.restore) {
                const restoredMatrix = transformStack.pop();
                if (restoredMatrix) {
                    transformMatrix = restoredMatrix;
                }
            }
            else if (fn === pdfjs.OPS.transform) {
                //transformMatrix = this.transform_fn(transformMatrix, args);
                transformMatrix = pdfjs.Util.transform(transformMatrix, args);
            }
        }
        return lineStore;
    }
    async fillPageTables(page, pageTables) {
        //const resultTable: Array<Table> = []
        const viewport = page.getViewport({ scale: 1 });
        // for (let i = 0; i < pageTables.length; i++) {
        //     const currentTable = pageTables[i]
        // }
        //pageTables = pageTables.filter((table) => table.cellCount > 3)
        const textContent = await page.getTextContent({
            includeMarkedContent: false,
            disableNormalization: false,
        });
        for (const textItem of textContent.items) {
            if (!('str' in textItem))
                continue;
            const tx = pdfjs.Util.transform(pdfjs.Util.transform(viewport.transform, textItem.transform), [1, 0, 0, -1, 0, 0]);
            //const resXY = viewport.convertToViewportPoint(tx[4], tx[5]);
            // textItem.transform = pdfjs.Util.transform(viewport.transform, textItem.transform)
            // textItem.transform[5] = viewport.height - textItem.transform[5] - textItem.height
            for (const pageTable of pageTables) {
                const cell = pageTable.findCell(tx[4], tx[5]);
                if (cell) {
                    cell.text.push(textItem.str);
                    if (textItem.hasEOL) {
                        cell.text.push('\n');
                    }
                    break;
                }
            }
            //Table.tryAddText(pageTables, textItem)
        }
    }
}
exports.PDFParse = PDFParse;
//# sourceMappingURL=PDFParse.js.map